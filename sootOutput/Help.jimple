public class Help extends java.lang.Object
{

    public void <init>()
    {
        Help this;

        this := @this: Help;

        specialinvoke this.<java.lang.Object: void <init>()>();

        return;
    }

    public static void printHelp()
    {
        java.io.PrintStream $stack0, $stack1;

        $stack0 = <java.lang.System: java.io.PrintStream out>;

        virtualinvoke $stack0.<java.io.PrintStream: void println(java.lang.String)>("Usage: ooc [options] files\n");

        $stack1 = <java.lang.System: java.io.PrintStream out>;

        virtualinvoke $stack1.<java.io.PrintStream: void println(java.lang.String)>("-v, -verbose                    verbose\n-g, -debug                      compile with debug information\n-noclean                        don\'t delete .c/.h files produced by\n                                the backend\n-gcc,-tcc,-icc,-clang,-onlygen  choose the compiler backend (default=gcc)\t\t\t\t\t\t\t\t onlygen doesn\'t launch any C compiler, and implies -noclean\n-gc=[dynamic,static,off]        link dynamically, link statically, or doesn\'t\n                                link with the Boehm GC at all.\n-driver=[combine,sequence]      choose the driver to use. combine does all in one,\n                                sequence does all the .c one after the other.\n-sourcepath=output/path/        location of your source files\n-outpath                        where to output the .c/.h files\n-Ipath, -incpath=path           where to find C headers\n-Lpath, -libpath=path           where to find libraries to link with\n-lmylib                         link with library \'mylib\'\n-timing                         print how much time it took to compile\n-r, -run                        runs the executable after compilation\n+option                         pass \'option\' to the C compiler, e.g. +-D_GNU_SOURCE, or +-O2\nFor help about the backend options, run \'ooc -help-backends\'");

        return;
    }

    public static void printHelpBackends()
    {
        java.io.PrintStream $stack0;

        $stack0 = <java.lang.System: java.io.PrintStream out>;

        virtualinvoke $stack0.<java.io.PrintStream: void println(java.lang.String)>("The available backends are: [none,gcc,make] and the default is gcc.\nnone             just outputs the .c/.h files (be sure to have a main func)\ngcc              call the GNU C compiler with appropriate options\nmake             generate a Makefile in the default output directory (ooc_tmp)\n\nFor help about a specific backend, run \'ooc -help-gcc\' for example");

        return;
    }

    public static void printHelpGcc()
    {
        java.io.PrintStream $stack0;

        $stack0 = <java.lang.System: java.io.PrintStream out>;

        virtualinvoke $stack0.<java.io.PrintStream: void println(java.lang.String)>("gcc backend options:\n-clean=[yes,no]        delete (or not) temporary files. default: yes.\n                       overriden by the global option -noclean\n-verbose=[yes,no]      print the gcc command lines called from the backend.\n                       overriden by the global options -v, -verbose\n-shout=[yes,no], -s    prints a big fat [ OK ] at the end of the compilation\n                       if it was successful (in green, on Linux platforms)\nany other option       passed to gcc\n");

        return;
    }

    public static void printHelpMake()
    {
        java.io.PrintStream $stack0;

        $stack0 = <java.lang.System: java.io.PrintStream out>;

        virtualinvoke $stack0.<java.io.PrintStream: void println(java.lang.String)>("make backend options:\n-cc=[gcc,icl]        write a Makefile to be compatible with the said compiler\n-link=libname.a      link with the static library libname.a\nany other option     passed to the compiler\n");

        return;
    }

    public static void printHelpNone()
    {
        java.io.PrintStream $stack0;
        double $stack1, $stack2;
        int $stack3, $stack4;
        java.lang.String $stack5, $stack6;

        $stack0 = <java.lang.System: java.io.PrintStream out>;

        $stack1 = staticinvoke <java.lang.Math: double random()>();

        $stack2 = $stack1 * 6.0;

        $stack3 = (int) $stack2;

        $stack4 = $stack3 + 31;

        $stack5 = staticinvoke <java.lang.String: java.lang.String valueOf(int)>($stack4);

        $stack6 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>($stack5) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Be sure to have a main function! No .c/.h file will be outputted otherwise.\n\u001b[0;32;\u0001m\n                 |                                  |\n  _ \\  _` |  __| __|  _ \\  __|    _ \\  _` |  _` |   |\n  __/ (   |\\__ \\ |    __/ |       __/ (   | (   |  _|\n\\___|\\__,_|____/\\__|\\___|_|     \\___|\\__, |\\__, |  _)\n                                     |___/ |___/     \n\u001b[m\nOh, one last thing: the cake is a lie. Too bad, eh.\n");

        virtualinvoke $stack0.<java.io.PrintStream: void println(java.lang.String)>($stack6);

        return;
    }
}
